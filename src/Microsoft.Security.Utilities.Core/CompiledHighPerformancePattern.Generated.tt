<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="$(TargetPath)" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.CodeDom.Compiler" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="Microsoft.Security.Utilities" #>
<#@ output extension=".cs" #>
<#@ CleanupBehavior processor="T4VSHost" CleanupAfterProcessingTemplate="true" #>
// <auto-generated/>

// Copyright (c) Microsoft. All rights reserved. Licensed under the MIT license.
// See LICENSE file in the project root for full license information.

/*****************************************************************************
 * WARNING: AUTO-GENERATED. DO NOT MODIFY THE C# SOURCE FILE.
 *
 * To regenerate, select the 'Debug' configuration in Visual Studio, open the
 * .tt file and hit Ctrl+S to save. You can also regenerate by right-clicking on
 * the .tt file in Solution Explorer and selecting 'Run Custom Tool', or debug
 * the generation using 'Debug T4 Template'.
 *
 * NOTE: This is using T4 instead of a roslyn generator because we must generate
 * the regular expression constants as input to the the regex source generator.
 * It does not appear to be possible to chain rolsyn generators in this way.
 *****************************************************************************/

<#= GenerateCode() #>
<#+
private string GenerateCode()
{
    try
    {
        var type = typeof(IdentifiableScan).Assembly.GetType("Microsoft.Security.Utilities.CompiledHighPerformancePattern", throwOnError: true);
        var method = type.GetMethod("GenerateAdditionalCode", BindingFlags.Static | BindingFlags.NonPublic);
        if (method == null)
        {
            throw new InvalidOperationException("Method 'GenerateAdditionalCode' not found. Make sure to use 'Debug' configuration.");
        }
        return (string)method.Invoke(null, Array.Empty<object>());
    }
    catch (Exception ex)
    {
        try {
            // Fallback code to keep things building while iterating on the
            // generator. The exception is logged and written to the output file
            // as a comment along with the smallest possible code that can keep
            // things building while you fix it.
            Host.LogErrors(new CompilerErrorCollection {
                new CompilerError(Host.TemplateFile, 1, 1, "", $"Error generating code: {ex}")
            });
            var sb = new System.Text.StringBuilder();
            sb.AppendLine("/* ERROR: ");
            sb.AppendLine(ex.ToString());
            sb.AppendLine("*/");
            sb.AppendLine("namespace Microsoft.Security.Utilities;");
            sb.AppendLine("partial class CompiledHighPerformancePattern {");
            sb.AppendLine("    private static partial CompiledHighPerformancePattern[] GetPatterns() => [];");
            sb.AppendLine("}");
            return sb.ToString();
        } catch (Exception ex2) {
            throw new AggregateException(ex, ex2);
        }
    }
}
#>